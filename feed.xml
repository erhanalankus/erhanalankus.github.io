<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-07-27T10:01:20+03:00</updated><id>/feed.xml</id><title type="html">Erhan Alankuş</title><subtitle>Yazılımcı, elektronik sevdalısı. Burada blog yazıyor.</subtitle><entry><title type="html">Zarupa Core Devcamp Ders Notları (4. Gün)</title><link href="/2019/07/27/zarupa-core-devcamp-ders-notlari-gun4.html" rel="alternate" type="text/html" title="Zarupa Core Devcamp Ders Notları (4. Gün)" /><published>2019-07-27T00:00:00+03:00</published><updated>2019-07-27T00:00:00+03:00</updated><id>/2019/07/27/zarupa-core-devcamp-ders-notlari-gun4</id><content type="html" xml:base="/2019/07/27/zarupa-core-devcamp-ders-notlari-gun4.html">&lt;h2 id=&quot;4-gün-20-ve-24-saatler-arası&quot;&gt;4. Gün (20. ve 24. saatler arası)&lt;/h2&gt;

&lt;p&gt;Bugünün gündemi bash ve vim idi, fakat başlangıçta package management konusunun üzerinden geçtik.&lt;/p&gt;

&lt;p&gt;Uygulama kurarken version, description, nereye kuruluyor, paket bağımlılıkları var mı, paket bazı şeyleri kırabilir mi?&lt;/p&gt;

&lt;p&gt;.deb dosyaları arşiv dosyları. zip değil ar kullanıyor.&lt;/p&gt;

&lt;p&gt;apt-cache policy [paket adı]&lt;/p&gt;

&lt;p&gt;apt show&lt;/p&gt;

&lt;p&gt;lib ile başlayanlar library demek, executable’ları yok, uygulamalar bu library’leri kullanıyor.&lt;/p&gt;

&lt;p&gt;suggests kısmında belirtilenleri de kursak iyi olur.&lt;/p&gt;

&lt;p&gt;dpkg -l, sistemde kurulu tüm paketleri gösterir.
dpkg -L, paketin bileşenlerinin yerlerini gösterir.&lt;/p&gt;

&lt;p&gt;/var/cache/apt/archives/ klasöründe yüklenmiş deb dosyaları saklanıyor&lt;/p&gt;

&lt;p&gt;sudo du -csh /var/cache/apt/archives/ ile bunların diskte kapladığı yeri gördük.&lt;/p&gt;

&lt;p&gt;Çekeceğimiz her şeyde sürüm çok önemli.&lt;/p&gt;

&lt;p&gt;cat /etc/lsb-release ile sistem bilgilerimizi gördük
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION=”Ubuntu 18.04.2 LTS”&lt;/p&gt;

&lt;p&gt;/etc/apt/sources.list’de paketler için kullanılan kaynakları gördük.&lt;/p&gt;

&lt;p&gt;Paketleri güncellemek için:
sudo apt update
sudo apt upgrade&lt;/p&gt;

&lt;p&gt;Sunucuda kafamıza göre güncelleme yapmıyoruz.&lt;/p&gt;

&lt;p&gt;vim’e ctags ekledik, metot isimlerini listeliyor, vs.&lt;/p&gt;

&lt;p&gt;apt remove la paket kaldırınca leftoverlar kalıyor
configleri değiştirdiysen onlara ellemiyor
apt purge, configleri falan da siliyor&lt;/p&gt;

&lt;p&gt;nginx çok hızlı. hız, her zaman birinci öncelik değil.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://debgen.simplylinux.ch/&quot;&gt;Debian Sources List Generator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;POSIX üzerine konuştuk. Herkesin hemfikir olduğu bir sistem, kimse ortamı domine edemesin. Signal’ların, process’lerin vs. standartlarını belirliyor.&lt;/p&gt;

&lt;p&gt;Cron’dan ayrı olarak Kernel’in bir scheduler’ı var.&lt;/p&gt;

&lt;p&gt;htop’da f7 ile process’leri nice etmece. Bi uygulamayı daha önemli olarak işaretlemece, kaynak kullanım önceliği.&lt;/p&gt;

&lt;p&gt;traceroute ile bi URL’e kaç HOP’ta gittiğimize baktık.&lt;/p&gt;

&lt;p&gt;shell, POSIX’in ifade ettiği bir şey.&lt;/p&gt;

&lt;p&gt;Bash nedir’in üzerinde durduk.&lt;/p&gt;

&lt;p&gt;Environmental variable’lar uppercase olur.&lt;/p&gt;

&lt;p&gt;echo $HOME dediğimizde HOME diye bi makrom vardı, bunu expand etmiş oldum.&lt;/p&gt;

&lt;p&gt;cp, mv, ls falan bunlar hep GNU utility.&lt;/p&gt;

&lt;p&gt;Bi dosyaya bash script yazdık, sonra onu komut yaptık(shortdate)&lt;/p&gt;

&lt;p&gt;Bash Reference Manual üzerinde uzunca durduk. Tanımlara baktık. Control operatörlerine baktık.&lt;/p&gt;

&lt;p&gt;&amp;amp;, fg, bg kullandık. Ctrl+Z ile stop ettik. jobs komutu ile arkada bişey kaldı mı kontrol ettik.&lt;/p&gt;

&lt;p&gt;environment variable’a backtick içinde bir komut ataması yaparken komutu çalıştırmaya çalışıyor, komut hata vermezse atama gerçekleşiyor&lt;/p&gt;

&lt;p&gt;paketler kurulurken uzun bi liste görüren iyi oku, hayır de
gnome env’a bi kde paketi kurmaya çaışırsan bilimum kde paketleri de yanında gelir&lt;/p&gt;

&lt;p&gt;openvim.com&lt;/p&gt;

&lt;p&gt;Vim üzerinde uzunca çalıştık&lt;/p&gt;

&lt;p&gt;y,p copy paste
v ile seçmeye başldık
0 ile satırbaşına döndü
seçerken $ ile sona kadar götürdük
:x ile xinci satıra gittik
:set nu&lt;/p&gt;

&lt;p&gt;multiple line insert
ctrl+v
down arrow
shift+ı
type
esc&lt;/p&gt;

&lt;p&gt;search and replace: :%s/test/dombak./g&lt;/p&gt;

&lt;p&gt;.bashrc gibi .vimrc var, buradan tüm dosyalarda nu olsun yapabiliriz
oraya set nu yazdık, oldu
yanlış bişey yazarsak vim açılırken uyarır&lt;/p&gt;

&lt;p&gt;/ ile search ettik. n, shift+n ile next/previous yaptık.&lt;/p&gt;

&lt;p&gt;vim’in plugin yöneticileri olduğuna değindik.&lt;/p&gt;

&lt;p&gt;Bu seferki notlar biraz özensiz oldu, kusra bakmayın.&lt;/p&gt;

&lt;p&gt;Sevgiler,&lt;/p&gt;

&lt;p&gt;Erhan&lt;/p&gt;</content><author><name></name></author><summary type="html">4. Gün (20. ve 24. saatler arası) Bugünün gündemi bash ve vim idi, fakat başlangıçta package management konusunun üzerinden geçtik. Uygulama kurarken version, description, nereye kuruluyor, paket bağımlılıkları var mı, paket bazı şeyleri kırabilir mi? .deb dosyaları arşiv dosyları. zip değil ar kullanıyor. apt-cache policy [paket adı] apt show lib ile başlayanlar library demek, executable’ları yok, uygulamalar bu library’leri kullanıyor. suggests kısmında belirtilenleri de kursak iyi olur. dpkg -l, sistemde kurulu tüm paketleri gösterir. dpkg -L, paketin bileşenlerinin yerlerini gösterir. /var/cache/apt/archives/ klasöründe yüklenmiş deb dosyaları saklanıyor sudo du -csh /var/cache/apt/archives/ ile bunların diskte kapladığı yeri gördük. Çekeceğimiz her şeyde sürüm çok önemli. cat /etc/lsb-release ile sistem bilgilerimizi gördük DISTRIB_ID=Ubuntu DISTRIB_RELEASE=18.04 DISTRIB_CODENAME=bionic DISTRIB_DESCRIPTION=”Ubuntu 18.04.2 LTS” /etc/apt/sources.list’de paketler için kullanılan kaynakları gördük. Paketleri güncellemek için: sudo apt update sudo apt upgrade Sunucuda kafamıza göre güncelleme yapmıyoruz. vim’e ctags ekledik, metot isimlerini listeliyor, vs. apt remove la paket kaldırınca leftoverlar kalıyor configleri değiştirdiysen onlara ellemiyor apt purge, configleri falan da siliyor nginx çok hızlı. hız, her zaman birinci öncelik değil. Debian Sources List Generator POSIX üzerine konuştuk. Herkesin hemfikir olduğu bir sistem, kimse ortamı domine edemesin. Signal’ların, process’lerin vs. standartlarını belirliyor. Cron’dan ayrı olarak Kernel’in bir scheduler’ı var. htop’da f7 ile process’leri nice etmece. Bi uygulamayı daha önemli olarak işaretlemece, kaynak kullanım önceliği. traceroute ile bi URL’e kaç HOP’ta gittiğimize baktık. shell, POSIX’in ifade ettiği bir şey. Bash nedir’in üzerinde durduk. Environmental variable’lar uppercase olur. echo $HOME dediğimizde HOME diye bi makrom vardı, bunu expand etmiş oldum. cp, mv, ls falan bunlar hep GNU utility. Bi dosyaya bash script yazdık, sonra onu komut yaptık(shortdate) Bash Reference Manual üzerinde uzunca durduk. Tanımlara baktık. Control operatörlerine baktık. &amp;amp;, fg, bg kullandık. Ctrl+Z ile stop ettik. jobs komutu ile arkada bişey kaldı mı kontrol ettik. environment variable’a backtick içinde bir komut ataması yaparken komutu çalıştırmaya çalışıyor, komut hata vermezse atama gerçekleşiyor paketler kurulurken uzun bi liste görüren iyi oku, hayır de gnome env’a bi kde paketi kurmaya çaışırsan bilimum kde paketleri de yanında gelir openvim.com Vim üzerinde uzunca çalıştık y,p copy paste v ile seçmeye başldık 0 ile satırbaşına döndü seçerken $ ile sona kadar götürdük :x ile xinci satıra gittik :set nu multiple line insert ctrl+v down arrow shift+ı type esc search and replace: :%s/test/dombak./g .bashrc gibi .vimrc var, buradan tüm dosyalarda nu olsun yapabiliriz oraya set nu yazdık, oldu yanlış bişey yazarsak vim açılırken uyarır / ile search ettik. n, shift+n ile next/previous yaptık. vim’in plugin yöneticileri olduğuna değindik. Bu seferki notlar biraz özensiz oldu, kusra bakmayın. Sevgiler, Erhan</summary></entry><entry><title type="html">Zarupa Core Devcamp Ders Notları (Telafi 2)</title><link href="/2019/07/26/zarupa-core-devcamp-ders-notlari-telafi2.html" rel="alternate" type="text/html" title="Zarupa Core Devcamp Ders Notları (Telafi 2)" /><published>2019-07-26T00:00:00+03:00</published><updated>2019-07-26T00:00:00+03:00</updated><id>/2019/07/26/zarupa-core-devcamp-ders-notlari-telafi2</id><content type="html" xml:base="/2019/07/26/zarupa-core-devcamp-ders-notlari-telafi2.html">&lt;h1 id=&quot;zarupa-core-devcamp-ders-notları&quot;&gt;Zarupa Core Devcamp Ders Notları&lt;/h1&gt;
&lt;h2 id=&quot;telafi-2-İkinci-10-saatin-4-saate-sıkıştırılmış-telafisi&quot;&gt;Telafi 2 (İkinci 10 saatin 4 saate sıkıştırılmış telafisi)&lt;/h2&gt;
&lt;p&gt;Bugün, müfredatın aşağıda listelediğim kısımları üzerinde durmamız gerekiyordu, fakat zaman yetişmedi, eksik kalan kısımların telafisini zamana yaymaya karar verdik.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.7. Symbolic and hard links
1.8. Compression and archiving
1.9. Search and find
1.10. Package management
1.11. Process management
1.12. Update, upgrade, backup
1.13. Scheduled tasks
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dmesg komutunu inceledik, bilgisayar açıldığından beri olan her şeyin oraya not düşülmüş olduğunu gördük. Daha sonra bilgisayara bir flash disk bağladığımızda onunla ilgili yapılmış işlemlerin oraya eklendiğini gördük.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface&quot;&gt;ACPI&lt;/a&gt; ve &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface&quot;&gt;AHCI&lt;/a&gt;‘den çok kısa bahsettik.&lt;/p&gt;

&lt;p&gt;/etc/systemd/system/sysinit.target.wants ‘a göz attık.&lt;/p&gt;

&lt;p&gt;AHCI’nin buglarıyla community’yi hep üzdüğüne değindik.&lt;/p&gt;

&lt;p&gt;whois komutuyla aldığımız bilgideki adresin, geolocation’a dair bir ipucu vermediğini belirttik.&lt;/p&gt;

&lt;p&gt;/dev/ klasörünü inceledik. Oradaki device’ları gördük.&lt;/p&gt;

&lt;p&gt;df -kh komutu ile makinamızdaki tüm partition’ları gördük.&lt;/p&gt;

&lt;p&gt;man komutuyla manual’ı çağırdığımızda gelen sayfaları less ile görüntülüyoruz gibi bir şey söyledik.&lt;/p&gt;

&lt;p&gt;D-Bus’ın interprocess communication(IPC) ile ilgili bir şey olduğunu söyledik. Şu linki incele: &lt;a href=&quot;https://dbus.freedesktop.org/doc/dbus-tutorial.html&quot;&gt;https://dbus.freedesktop.org/doc/dbus-tutorial.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Disklere &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;UUID&lt;/a&gt; atandığını ve disklerin o UUID’ler ile tanındığını söyledik.&lt;/p&gt;

&lt;p&gt;Her dosyanın SUID’si, SGID’si var gibi bir şeyler söyledik, tamamlamadık. Bu konu bana ödev verildi.&lt;/p&gt;

&lt;p&gt;Konsolda iyi, ne yaptığını bilen kişiler olmamız gerektiğini konuştuk.&lt;/p&gt;

&lt;p&gt;file /dev/sda komutu ile bunun bir block special (8/0) olduğunu gördük. Disk’e block device dendiğini söyledik.&lt;/p&gt;

&lt;p&gt;ls /proc/ ile process’leri gördük.&lt;/p&gt;

&lt;p&gt;Ctrl+K kısayolu ile cursor’ın sağını uçurabileceğimizi gördük.&lt;/p&gt;

&lt;p&gt;cat /proc/partitions ile partition’lara göz attık.&lt;/p&gt;

&lt;p&gt;sda, sdb şeklinde disk identifer’lar var. Bunlar eskiden hd ile başlıyormuş, şimdi sd ile başlıyor. sr0 ile cdrom sürücü veya benzeri drive işaret ediliyor.&lt;/p&gt;

&lt;p&gt;home klasörümüzü ayrı bir partition’a koyarsak işletim sistemine yapacağımız büyük değişikler, dosyalarımızı etkilemez.&lt;/p&gt;

&lt;p&gt;RAM bitince diskteki SWAP alanı kullanılır. Bu alanda özel bir dosya sistemi kullanıldığı için hızlı çalışır.&lt;/p&gt;

&lt;p&gt;Disk, aniden ulaşılamaz hale gelirse “kernel panic” durumu yaşanır.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_device&quot;&gt;Loop Device&lt;/a&gt; : is a pseudo-device that makes a file accessible as a block device.&lt;/p&gt;

&lt;p&gt;Ctrl+W ile bir kelime silebiliriz.&lt;/p&gt;

&lt;p&gt;mount komutu ile mount edilmiş her şeyi görürüz. Diskler için sda ve sdb’leri ara.&lt;/p&gt;

&lt;p&gt;htop, çalışan processleri izlemek için güzel bir alternatif, yükledik.&lt;/p&gt;

&lt;p&gt;mkdir ve touch ile bol bol oynadık, basit bir for döngüzü yazdık.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	for i in {01..20}; do touch file-$i; done;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dosya isimlerinde boşluk, türkçe harf, ‘-‘ harici özel karakter kullanmıyoruz.&lt;/p&gt;

&lt;p&gt;Klasörlerdeki parent-child ilişkilerini konuştuk. Bol bol cp yaptık. mv’nin recursion’a takılmadığını, -r eklemek gerekmediğini gördük.&lt;/p&gt;

&lt;p&gt;Bash’te yazmakta olduğumuz satırda, bulunduğumuz klasörü gösteren kısmın solundaki kısma(bende erhan@erhan-Lenovo-Z50-70: olarak geçiyor) ps1 diyormuşuz.&lt;/p&gt;

&lt;p&gt;Absolute ve relative path’ler üzerinde durduk.&lt;/p&gt;

&lt;p&gt;tar kullandık. Arşivledik, açtık. tar’ın sıkıştırma yapmadığını, sıkıştırma yapmak için farklı sıkıştırma algoritmaları kullanabileceğimizi gördük. Bash’teki autocomplete’in bu kullanılmış algoritmaları hesaba katarak autocomplete yaptığını gördük.&lt;/p&gt;

&lt;p&gt;Asla rm -rf yapmamamız gerektiğini söyledik. Linux’ta kullanıcı hareketleri regüle edilmez, bu güzel bir şeydir, ama dikkatli olmazsak makinamızı bozabiliriz.&lt;/p&gt;

&lt;p&gt;ln ‘ye bir göz attık. Symbolic link yaptık. Kaynak dosyayı silince, symbolic link’in broken state’e geçtiğini gördük.&lt;/p&gt;

&lt;p&gt;history komutu ile Linux’u yüklediğimizden beri girmiş olduğumuz tüm komutları gördük. .bashrc’de HISTSIZE ve HISTFILESIZE’a üç sıfır ekledik.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/junegunn/fzf&quot;&gt;Command-line fuzzy finder&lt;/a&gt; yükledik. Ctrl+R ile eski girilmiş komutları arama kısmı çok daha lezzetli oldu.&lt;/p&gt;

&lt;p&gt;env komutu ile environment variable’ları gördük.&lt;/p&gt;

&lt;p&gt;Umarım önemli bir şey atlamamışımdır.&lt;/p&gt;

&lt;p&gt;Sevgiler,&lt;/p&gt;

&lt;p&gt;Erhan&lt;/p&gt;</content><author><name></name></author><summary type="html">Zarupa Core Devcamp Ders Notları Telafi 2 (İkinci 10 saatin 4 saate sıkıştırılmış telafisi) Bugün, müfredatın aşağıda listelediğim kısımları üzerinde durmamız gerekiyordu, fakat zaman yetişmedi, eksik kalan kısımların telafisini zamana yaymaya karar verdik. 1.7. Symbolic and hard links 1.8. Compression and archiving 1.9. Search and find 1.10. Package management 1.11. Process management 1.12. Update, upgrade, backup 1.13. Scheduled tasks dmesg komutunu inceledik, bilgisayar açıldığından beri olan her şeyin oraya not düşülmüş olduğunu gördük. Daha sonra bilgisayara bir flash disk bağladığımızda onunla ilgili yapılmış işlemlerin oraya eklendiğini gördük. ACPI ve AHCI‘den çok kısa bahsettik. /etc/systemd/system/sysinit.target.wants ‘a göz attık. AHCI’nin buglarıyla community’yi hep üzdüğüne değindik. whois komutuyla aldığımız bilgideki adresin, geolocation’a dair bir ipucu vermediğini belirttik. /dev/ klasörünü inceledik. Oradaki device’ları gördük. df -kh komutu ile makinamızdaki tüm partition’ları gördük. man komutuyla manual’ı çağırdığımızda gelen sayfaları less ile görüntülüyoruz gibi bir şey söyledik. D-Bus’ın interprocess communication(IPC) ile ilgili bir şey olduğunu söyledik. Şu linki incele: https://dbus.freedesktop.org/doc/dbus-tutorial.html. Disklere UUID atandığını ve disklerin o UUID’ler ile tanındığını söyledik. Her dosyanın SUID’si, SGID’si var gibi bir şeyler söyledik, tamamlamadık. Bu konu bana ödev verildi. Konsolda iyi, ne yaptığını bilen kişiler olmamız gerektiğini konuştuk. file /dev/sda komutu ile bunun bir block special (8/0) olduğunu gördük. Disk’e block device dendiğini söyledik. ls /proc/ ile process’leri gördük. Ctrl+K kısayolu ile cursor’ın sağını uçurabileceğimizi gördük. cat /proc/partitions ile partition’lara göz attık. sda, sdb şeklinde disk identifer’lar var. Bunlar eskiden hd ile başlıyormuş, şimdi sd ile başlıyor. sr0 ile cdrom sürücü veya benzeri drive işaret ediliyor. home klasörümüzü ayrı bir partition’a koyarsak işletim sistemine yapacağımız büyük değişikler, dosyalarımızı etkilemez. RAM bitince diskteki SWAP alanı kullanılır. Bu alanda özel bir dosya sistemi kullanıldığı için hızlı çalışır. Disk, aniden ulaşılamaz hale gelirse “kernel panic” durumu yaşanır. Loop Device : is a pseudo-device that makes a file accessible as a block device. Ctrl+W ile bir kelime silebiliriz. mount komutu ile mount edilmiş her şeyi görürüz. Diskler için sda ve sdb’leri ara. htop, çalışan processleri izlemek için güzel bir alternatif, yükledik. mkdir ve touch ile bol bol oynadık, basit bir for döngüzü yazdık. for i in {01..20}; do touch file-$i; done; Dosya isimlerinde boşluk, türkçe harf, ‘-‘ harici özel karakter kullanmıyoruz. Klasörlerdeki parent-child ilişkilerini konuştuk. Bol bol cp yaptık. mv’nin recursion’a takılmadığını, -r eklemek gerekmediğini gördük. Bash’te yazmakta olduğumuz satırda, bulunduğumuz klasörü gösteren kısmın solundaki kısma(bende erhan@erhan-Lenovo-Z50-70: olarak geçiyor) ps1 diyormuşuz. Absolute ve relative path’ler üzerinde durduk. tar kullandık. Arşivledik, açtık. tar’ın sıkıştırma yapmadığını, sıkıştırma yapmak için farklı sıkıştırma algoritmaları kullanabileceğimizi gördük. Bash’teki autocomplete’in bu kullanılmış algoritmaları hesaba katarak autocomplete yaptığını gördük. Asla rm -rf yapmamamız gerektiğini söyledik. Linux’ta kullanıcı hareketleri regüle edilmez, bu güzel bir şeydir, ama dikkatli olmazsak makinamızı bozabiliriz. ln ‘ye bir göz attık. Symbolic link yaptık. Kaynak dosyayı silince, symbolic link’in broken state’e geçtiğini gördük. history komutu ile Linux’u yüklediğimizden beri girmiş olduğumuz tüm komutları gördük. .bashrc’de HISTSIZE ve HISTFILESIZE’a üç sıfır ekledik. Command-line fuzzy finder yükledik. Ctrl+R ile eski girilmiş komutları arama kısmı çok daha lezzetli oldu. env komutu ile environment variable’ları gördük. Umarım önemli bir şey atlamamışımdır. Sevgiler, Erhan</summary></entry><entry><title type="html">Zarupa Core Devcamp Ders Notları (Telafi 1)</title><link href="/2019/07/25/zarupa-core-devcamp-ders-notlari-telafi1.html" rel="alternate" type="text/html" title="Zarupa Core Devcamp Ders Notları (Telafi 1)" /><published>2019-07-25T00:00:00+03:00</published><updated>2019-07-25T00:00:00+03:00</updated><id>/2019/07/25/zarupa-core-devcamp-ders-notlari-telafi1</id><content type="html" xml:base="/2019/07/25/zarupa-core-devcamp-ders-notlari-telafi1.html">&lt;h1 id=&quot;zarupa-core-devcamp-ders-notları&quot;&gt;Zarupa Core Devcamp Ders Notları&lt;/h1&gt;
&lt;h2 id=&quot;telafi-1-İlk-10-saatin-4-saate-sıkıştırılmış-telafisi&quot;&gt;Telafi 1 (İlk 10 saatin 4 saate sıkıştırılmış telafisi)&lt;/h2&gt;
&lt;p&gt;Bugün, müfredatın aşağıda listelediğim kısımları üzerinde durduk:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0. Introduction
	0.1. Welcome!
	0.2. What is Free Software?
	0.3. Free Software philosophy
	0.4. A Brief history of GNU/Linux OS
	0.5. Software licenses
1. GNU/Linux for Developers
	1.1. GNU/Linux OS distros
	1.2. What is an operating system?
	1.3. Components of GNU/Linux OS
	1.4. Boot sequence of Linux
	1.5. User and group management
	1.6. File system hierarchy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Neden Linux’u seçtiğimiz konusu ile başladık.
Üzerinde çalıştığımız işletim sisteminin çalışma mekaniğini anlamamız gerektiğine, anlamadığımız yerde durup o kısmı anladıktan sonra devam etmemiz gerektiğine değindik.
Üç ana işletim sistemi olduğunu söyledik: Linux, Unix ve Windows. Mainframe’lerde çalışan High Performance Computing(HPC) sistemlerinin alanımız dışında olduğunu söyledik, bunların yüzde sekseni Unix-Linux türevleri çalıştırıyormuş.&lt;/p&gt;

&lt;p&gt;Windows’u pas geçiyoruz çünkü geliştirici dostu gibi görünen bir işletim sistemi. Prototipler üretmesi kolay, fakat kullanıcısına eziyet eden bir işletim sistemi. Pazarda geriye düştükleri için open source’a yöneldiler, fakat free software’in üstünlüğü devam ediyor.&lt;/p&gt;

&lt;p&gt;Biz bütün dünyada çalışabilecek “Gerilla Geliştirici”ler olacağımızdan, daha evrensel olan Linux üzerinde çalışmayı seçiyoruz.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/mycVSMyShk8&quot;&gt;Linux Kernel&lt;/a&gt; etrafında oluşturulmuş farklı dağıtımlar var. Hepsi Linux Kernel kullanır. Dağıtımlar hakkındaki bilgileri &lt;a href=&quot;https://distrowatch.com/&quot;&gt;distrowatch.com&lt;/a&gt; sitesinden takip edebiliriz.&lt;/p&gt;

&lt;p&gt;Asıl mesele Kernel, fakat Kernel, işletim sistemi için yeterli değil. &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU&quot;&gt;GNU&lt;/a&gt; ile &lt;a href=&quot;https://youtu.be/RNeKYjWx-s4&quot;&gt;kullanıcı ve bilgisayar arasındaki ilişki yönetiliyor&lt;/a&gt;. GNU, bunun için tek seçenek değil. GNU, bir geliştirme ve yaşam felsefesi. Başında Richard Stallman var.&lt;/p&gt;

&lt;p&gt;Linux, tüm dünyada kullanılıyor. Linux ile uğraşan bir çok topluluk var. Dağıtımlardaki minik parçaların geliştirmelerini, bakımlarını yapıyorlar. Debian ve RedHat iki ana akım, diğer dağıtımlar bunlar üzerine inşa edilir. Ubuntu, Debian’dan türemiştir. Redhat, CentOS; RedHat’ten türemiştir. Linux dağıtımlarının sistem gereksinimleri genellikle düşüktür. Linux, uyumluluk için tasarlanmıştır, çalışma ekosistemleri için yaratılmıştır. Linux işletim sistemlerinin her parçasını kafamıza göre değiştirebiliriz.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/lrcdhzr2qnk&quot;&gt;Free Software ve Open Source farklı şeyler&lt;/a&gt;. Free Software terimindeki “free” kelimesini “free speech”teki gibi anlamalıyız. Open Source hareketi, bu kısma yeterince önem vermiyor. Free Software topluluğu, aktif yardımlaşma içinde bir topluluk, fakat soru sorarken &lt;a href=&quot;[http://www.catb.org/~esr/faqs/smart-questions.html](http://www.catb.org/~esr/faqs/smart-questions.html)&quot;&gt;kuralına göre&lt;/a&gt; sormak gerekiyor.&lt;/p&gt;

&lt;p&gt;Linux’u anlamak için Unix’i anlamak gerekiyor. Bell laboratuvarlarında &lt;a href=&quot;https://en.wikipedia.org/wiki/Multics&quot;&gt;Multics&lt;/a&gt; projesi olarak başlıyor. Çok kullanıcılı bir işletim sistemi projesi olarak başlıyor fakat bir noktada bu proje duruyor. Daha sonra 72-73 yıllarında projeye portability kazandırmak için C ile devam ediyorlar. &lt;a href=&quot;https://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; standardını geliştiriyorlar. Proje portability sayesinde, her işlemcide çalışarak hayatta kalıyor. Sun Microsystems, ilk ticari Unix vendörü olarak işe dalıyor. Berkeley’de BSD Unix yapıyorlar ve bundan esinlenen bir sürü işletim sistemi yapılıyor. &lt;a href=&quot;https://en.wikipedia.org/wiki/NeXTSTEP&quot;&gt;NeXTSTEP&lt;/a&gt;, Apple’ın işletim sistemine dönüşüyor. &lt;a href=&quot;https://en.wikipedia.org/wiki/MINIX&quot;&gt;MINIX&lt;/a&gt;, Linus Torvalds sayesinde Linux oluyor.&lt;/p&gt;

&lt;p&gt;Unix’in bakış açıları:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Clarity: Kısıtlı ve iyi belirlenmiş bir yol haritası.&lt;/li&gt;
  &lt;li&gt;Portability: C’de yazılmış olması sayesinde her yerde çalışabilmesi.&lt;/li&gt;
  &lt;li&gt;Simultaneity: Birden fazla kullanıcının özgürce yapacağı işlemleri kaldırabilmesi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GNU’yu Richard Stallman başlatıyor. GNU, Free Software Foundation’ın odağı haline geliyor. GNU Projesinin Unix’in yerine kullanmak üzere geliştirmeye başladığı &lt;a href=&quot;https://www.gnu.org/software/hurd/&quot;&gt;GNU Hurd&lt;/a&gt; projesi 1985’ten beri meyve verememiş.&lt;/p&gt;

&lt;p&gt;Linus Torvalds, 1991’de MINIX kullanan bir işletim sistemi yapıyor, ve bu işletim sistemi popüler oluyor. 1994’te 1.0 versiyonu yayınlanıyor. GNU ve Kernel’ı birlikte kullanma kararı alıyor, ve böylece diğer dağıtımlar da bunu kullanır oluyor.&lt;/p&gt;

&lt;p&gt;Free Software topluluğu GNU tarafında duruyor. Linux tarafı Unix’ten çok şey aldı. Bir çok kaynaktan bir şeyler kullanarak bir işletim sistemi çıkarıyor.&lt;/p&gt;

&lt;p&gt;Yazılım lisanslarına kısaca değindik. &lt;a href=&quot;http://ozgurlisanslar.org.tr/&quot;&gt;ozgurlisanslar.org.tr&lt;/a&gt; sitesinden yazılım lisanslarını öğrenebiliriz. GPL lisansı güzel, fakat kodu açık tutma zorunluluğu getirmesi yüzünden kapitalistler tarafından sevilmiyor. &lt;a href=&quot;https://en.wikipedia.org/wiki/BSD_licenses&quot;&gt;BSD lisanslarının&lt;/a&gt; iyi olmadığına değindik.&lt;/p&gt;

&lt;p&gt;Linux, preemptive, gerçek zamanlı olarak donanım detaylarıyla baş edebiliyor.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uname -a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Komutunun çıktısında;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Linux vm-us 4.18.0-1023-azure #24~18.04.1-Ubuntu SMP Tue Jun 25 15:14:42 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“GNU/Linux” u gördük, Richard Stallman’ın kazandığını belirttik.&lt;/p&gt;

&lt;p&gt;Projelerde asıl meselenin minimum kaynak kullanma olduğuna değindik.&lt;/p&gt;

&lt;p&gt;Debian ve RedHat iki ana linux dağıtımı, paket yönetim sistemleri farklı. Bunların bir çok türevleri var. RedHat tarafında Fedora(şirket içi), RedHat(ticari) ve CentOS(ücretsiz). CentOS ücretsiz olarak kullanılabiliyor. Bakım, SLA, destek isteyenler RedHat satın alıyor.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bsd.org/&quot;&gt;BSD&lt;/a&gt;‘nin önemli olduğunu söyledik ama ne olduğu üzerinde durmadık. OpenBSD projesinde dokuz yılda bir adet bug bulunduğunu söyledik. &lt;a href=&quot;https://www.apache.org/foundation/&quot;&gt;Apache Foundation&lt;/a&gt;‘ı andık ama üzerine konuşmadık.&lt;/p&gt;

&lt;p&gt;Bizim işimiz etrafında çok fazla bilgi olduğundan bahsettik. O anda yaptığımız iş ile ilgili detaylara odaklanalım, diğer unsurları o konudan ayrı tutalım dedik. Neyi nasıl hatırlayacağımızı öğrendiğimizden, herşeyi hatırlamaya çalışmayacağımızdan bahsettik.&lt;/p&gt;

&lt;p&gt;Hardware&amp;lt;Kernel&amp;lt;Shell&amp;lt;X and Window Manager&amp;lt;User şeklinde bir şemayı inceledik. İşletim sistemi ve bilgisayar ile ilgili çeşitli şemalar inceledik.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lspci, lsusb, lsdev, lsmod, modinfo, w, whoami, last, uptime  komutlarını inceledik.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ip adreslerinin A class, B class gibi sınıfları olduğuna değindik. &lt;a href=&quot;https://study-ccna.com/classes-of-ip-addresses/&quot;&gt;Detayına&lt;/a&gt; girmedik.&lt;/p&gt;

&lt;p&gt;SCI, PM, VFS, MM, Network Stack, Arch, Device Drivers içeren bir şema inceledik. Bunun ne olduğunu unuttum.&lt;/p&gt;

&lt;p&gt;Storage türlerinden bahsettik. DAS, direct attached storage, bilgisayarımıza doğrudan bağlı storage. Uzaktan bağlanan storage’lardan NAS ve SAN’a değindik.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;netstat, sudo netstat -nlp, netstat -s komutlarını inceledik. Farenin orta tuşuna basarak seçili metni copy&amp;amp;paste yapabileceğimizi gördük.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Boot Sequence’a değindik. Şöyle bir sıradan bahsettik:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BIOS: Basic Input Output System. Bağlı donanımları biliyor.&lt;/li&gt;
  &lt;li&gt;MBR: Master Boot Record. GRUB’u çalıştırır. Windows’ta sıfırıncı sektörde olmak zorunda.&lt;/li&gt;
  &lt;li&gt;GRUB: Grand Unified Bootloader. Kernel’i çalıştırır&lt;/li&gt;
  &lt;li&gt;Kernel: /sbin/init ‘i çalıştırır&lt;/li&gt;
  &lt;li&gt;Init: Runlevel programlarını çalıştırır.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Systemd’nin SystemV’nin yerine geldiğini söyledik.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Runlevel&quot;&gt;Runlevel&lt;/a&gt; ‘lardan bahsettik. Çok kullanıcılı bir işletim sisteminde bakım yapacağımız zaman runlevel set ederek, işletim sistemini tek kullanıcılı bir işletim sistemi haline getirip bakım yapabileceğimizi söyledik. runlevel komutu ile sistemin o an hangi runlevel’da olduğunu görebileceğimizi gördük. Runlevel’ı sıfıra set ederek makinayı programatik olarak kapatabileceğimize değindik.&lt;/p&gt;

&lt;p&gt;Linux’un, tam programlanabilir bir ortam olduğunu söyledik.&lt;/p&gt;

&lt;p&gt;Windows’ta file system hierarchy olmadığını, Windows’un çok kullanıcılı bir işletim sistemi olarak tasarlanmadığını söyledik.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/index.html&quot;&gt;Linux Filesystem Hierarchy&lt;/a&gt;‘ye geçtik. Bunun bilinmesinin gerekliliğine vurgu yaptık. “/” sembolünün herhangi bir diski değil, işletim sisteminin kökünü temsil ettiğini söyledik.&lt;/p&gt;

&lt;p&gt;dmesg komutuna göz attık. dbus’ı atladığımızı fark ettik.&lt;/p&gt;

&lt;p&gt;netcat’i anlamanın çok önemli olduğunu, netcat’in hacker’ların isviçre çakısı olduğuna değindik.&lt;/p&gt;

&lt;p&gt;/etc/bash_completion’a göz attık.&lt;/p&gt;

&lt;p&gt;Bizim işimizde hiç bir şeyin otomatik olmayacağını, her işimizi manuel yapacağımızı söyledik.&lt;/p&gt;

&lt;p&gt;ps komutu ile, o anda çalışmakta olan &lt;a href=&quot;https://www.tecmint.com/linux-process-management/&quot;&gt;process&lt;/a&gt;‘leri listeleyebileceğimizi gördük. ps -aux | grep bash komutu ile bash ile ilgili process’leri gördük.&lt;/p&gt;

&lt;p&gt;Tehlikeli olabileceğini düşündüğümüz komutlar hakkında man ve info komutlarını kullanarak bilgi alabileceğimizi gördük. apropos komutu ile benzer komutları listelettik.&lt;/p&gt;

&lt;p&gt;Binary File’ın derlenmiş ve çalıştırılabilir dosya demek olduğunu söyledik. file komutu ile dosya türünü görebileceğimizi gördük.&lt;/p&gt;

&lt;p&gt;Ctrl+A ve Ctrl+E ile yazmakta olduğumuz satırın başına veya sonuna atlayabileceğimizi gördük.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html&quot;&gt;/proc&lt;/a&gt; klasörüne göz attık.&lt;/p&gt;

&lt;p&gt;tecmint.com’un iyi bir kaynak olduğunu söyledik. Gnome’un bir window manager olduğunu söyledik.
“Hard Link” ve “Soft Link” kavramlarını bir sınıf arkadaşımızdan öğreneceğimizin haberini aldık :)
SID ve GID nedir? Araştırma ödevi verildi.
“&amp;gt;”(redirection) ve “»“(concatenation) komutlarını inceledik. touch komutuyla oynadık.&lt;/p&gt;

&lt;p&gt;Umarım önemli bir şey atlamamışımdır.&lt;/p&gt;

&lt;p&gt;Sevgiler,
Erhan&lt;/p&gt;</content><author><name></name></author><summary type="html">Zarupa Core Devcamp Ders Notları Telafi 1 (İlk 10 saatin 4 saate sıkıştırılmış telafisi) Bugün, müfredatın aşağıda listelediğim kısımları üzerinde durduk: 0. Introduction 0.1. Welcome! 0.2. What is Free Software? 0.3. Free Software philosophy 0.4. A Brief history of GNU/Linux OS 0.5. Software licenses 1. GNU/Linux for Developers 1.1. GNU/Linux OS distros 1.2. What is an operating system? 1.3. Components of GNU/Linux OS 1.4. Boot sequence of Linux 1.5. User and group management 1.6. File system hierarchy Neden Linux’u seçtiğimiz konusu ile başladık. Üzerinde çalıştığımız işletim sisteminin çalışma mekaniğini anlamamız gerektiğine, anlamadığımız yerde durup o kısmı anladıktan sonra devam etmemiz gerektiğine değindik. Üç ana işletim sistemi olduğunu söyledik: Linux, Unix ve Windows. Mainframe’lerde çalışan High Performance Computing(HPC) sistemlerinin alanımız dışında olduğunu söyledik, bunların yüzde sekseni Unix-Linux türevleri çalıştırıyormuş. Windows’u pas geçiyoruz çünkü geliştirici dostu gibi görünen bir işletim sistemi. Prototipler üretmesi kolay, fakat kullanıcısına eziyet eden bir işletim sistemi. Pazarda geriye düştükleri için open source’a yöneldiler, fakat free software’in üstünlüğü devam ediyor. Biz bütün dünyada çalışabilecek “Gerilla Geliştirici”ler olacağımızdan, daha evrensel olan Linux üzerinde çalışmayı seçiyoruz. Linux Kernel etrafında oluşturulmuş farklı dağıtımlar var. Hepsi Linux Kernel kullanır. Dağıtımlar hakkındaki bilgileri distrowatch.com sitesinden takip edebiliriz. Asıl mesele Kernel, fakat Kernel, işletim sistemi için yeterli değil. GNU ile kullanıcı ve bilgisayar arasındaki ilişki yönetiliyor. GNU, bunun için tek seçenek değil. GNU, bir geliştirme ve yaşam felsefesi. Başında Richard Stallman var. Linux, tüm dünyada kullanılıyor. Linux ile uğraşan bir çok topluluk var. Dağıtımlardaki minik parçaların geliştirmelerini, bakımlarını yapıyorlar. Debian ve RedHat iki ana akım, diğer dağıtımlar bunlar üzerine inşa edilir. Ubuntu, Debian’dan türemiştir. Redhat, CentOS; RedHat’ten türemiştir. Linux dağıtımlarının sistem gereksinimleri genellikle düşüktür. Linux, uyumluluk için tasarlanmıştır, çalışma ekosistemleri için yaratılmıştır. Linux işletim sistemlerinin her parçasını kafamıza göre değiştirebiliriz. Free Software ve Open Source farklı şeyler. Free Software terimindeki “free” kelimesini “free speech”teki gibi anlamalıyız. Open Source hareketi, bu kısma yeterince önem vermiyor. Free Software topluluğu, aktif yardımlaşma içinde bir topluluk, fakat soru sorarken kuralına göre sormak gerekiyor. Linux’u anlamak için Unix’i anlamak gerekiyor. Bell laboratuvarlarında Multics projesi olarak başlıyor. Çok kullanıcılı bir işletim sistemi projesi olarak başlıyor fakat bir noktada bu proje duruyor. Daha sonra 72-73 yıllarında projeye portability kazandırmak için C ile devam ediyorlar. POSIX standardını geliştiriyorlar. Proje portability sayesinde, her işlemcide çalışarak hayatta kalıyor. Sun Microsystems, ilk ticari Unix vendörü olarak işe dalıyor. Berkeley’de BSD Unix yapıyorlar ve bundan esinlenen bir sürü işletim sistemi yapılıyor. NeXTSTEP, Apple’ın işletim sistemine dönüşüyor. MINIX, Linus Torvalds sayesinde Linux oluyor. Unix’in bakış açıları: Clarity: Kısıtlı ve iyi belirlenmiş bir yol haritası. Portability: C’de yazılmış olması sayesinde her yerde çalışabilmesi. Simultaneity: Birden fazla kullanıcının özgürce yapacağı işlemleri kaldırabilmesi. GNU’yu Richard Stallman başlatıyor. GNU, Free Software Foundation’ın odağı haline geliyor. GNU Projesinin Unix’in yerine kullanmak üzere geliştirmeye başladığı GNU Hurd projesi 1985’ten beri meyve verememiş. Linus Torvalds, 1991’de MINIX kullanan bir işletim sistemi yapıyor, ve bu işletim sistemi popüler oluyor. 1994’te 1.0 versiyonu yayınlanıyor. GNU ve Kernel’ı birlikte kullanma kararı alıyor, ve böylece diğer dağıtımlar da bunu kullanır oluyor. Free Software topluluğu GNU tarafında duruyor. Linux tarafı Unix’ten çok şey aldı. Bir çok kaynaktan bir şeyler kullanarak bir işletim sistemi çıkarıyor. Yazılım lisanslarına kısaca değindik. ozgurlisanslar.org.tr sitesinden yazılım lisanslarını öğrenebiliriz. GPL lisansı güzel, fakat kodu açık tutma zorunluluğu getirmesi yüzünden kapitalistler tarafından sevilmiyor. BSD lisanslarının iyi olmadığına değindik. Linux, preemptive, gerçek zamanlı olarak donanım detaylarıyla baş edebiliyor. uname -a Komutunun çıktısında; Linux vm-us 4.18.0-1023-azure #24~18.04.1-Ubuntu SMP Tue Jun 25 15:14:42 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux “GNU/Linux” u gördük, Richard Stallman’ın kazandığını belirttik. Projelerde asıl meselenin minimum kaynak kullanma olduğuna değindik. Debian ve RedHat iki ana linux dağıtımı, paket yönetim sistemleri farklı. Bunların bir çok türevleri var. RedHat tarafında Fedora(şirket içi), RedHat(ticari) ve CentOS(ücretsiz). CentOS ücretsiz olarak kullanılabiliyor. Bakım, SLA, destek isteyenler RedHat satın alıyor. BSD‘nin önemli olduğunu söyledik ama ne olduğu üzerinde durmadık. OpenBSD projesinde dokuz yılda bir adet bug bulunduğunu söyledik. Apache Foundation‘ı andık ama üzerine konuşmadık. Bizim işimiz etrafında çok fazla bilgi olduğundan bahsettik. O anda yaptığımız iş ile ilgili detaylara odaklanalım, diğer unsurları o konudan ayrı tutalım dedik. Neyi nasıl hatırlayacağımızı öğrendiğimizden, herşeyi hatırlamaya çalışmayacağımızdan bahsettik. Hardware&amp;lt;Kernel&amp;lt;Shell&amp;lt;X and Window Manager&amp;lt;User şeklinde bir şemayı inceledik. İşletim sistemi ve bilgisayar ile ilgili çeşitli şemalar inceledik. lspci, lsusb, lsdev, lsmod, modinfo, w, whoami, last, uptime komutlarını inceledik. Ip adreslerinin A class, B class gibi sınıfları olduğuna değindik. Detayına girmedik. SCI, PM, VFS, MM, Network Stack, Arch, Device Drivers içeren bir şema inceledik. Bunun ne olduğunu unuttum. Storage türlerinden bahsettik. DAS, direct attached storage, bilgisayarımıza doğrudan bağlı storage. Uzaktan bağlanan storage’lardan NAS ve SAN’a değindik. netstat, sudo netstat -nlp, netstat -s komutlarını inceledik. Farenin orta tuşuna basarak seçili metni copy&amp;amp;paste yapabileceğimizi gördük. Boot Sequence’a değindik. Şöyle bir sıradan bahsettik: BIOS: Basic Input Output System. Bağlı donanımları biliyor. MBR: Master Boot Record. GRUB’u çalıştırır. Windows’ta sıfırıncı sektörde olmak zorunda. GRUB: Grand Unified Bootloader. Kernel’i çalıştırır Kernel: /sbin/init ‘i çalıştırır Init: Runlevel programlarını çalıştırır. Systemd’nin SystemV’nin yerine geldiğini söyledik. Runlevel ‘lardan bahsettik. Çok kullanıcılı bir işletim sisteminde bakım yapacağımız zaman runlevel set ederek, işletim sistemini tek kullanıcılı bir işletim sistemi haline getirip bakım yapabileceğimizi söyledik. runlevel komutu ile sistemin o an hangi runlevel’da olduğunu görebileceğimizi gördük. Runlevel’ı sıfıra set ederek makinayı programatik olarak kapatabileceğimize değindik. Linux’un, tam programlanabilir bir ortam olduğunu söyledik. Windows’ta file system hierarchy olmadığını, Windows’un çok kullanıcılı bir işletim sistemi olarak tasarlanmadığını söyledik. Linux Filesystem Hierarchy‘ye geçtik. Bunun bilinmesinin gerekliliğine vurgu yaptık. “/” sembolünün herhangi bir diski değil, işletim sisteminin kökünü temsil ettiğini söyledik. dmesg komutuna göz attık. dbus’ı atladığımızı fark ettik. netcat’i anlamanın çok önemli olduğunu, netcat’in hacker’ların isviçre çakısı olduğuna değindik. /etc/bash_completion’a göz attık. Bizim işimizde hiç bir şeyin otomatik olmayacağını, her işimizi manuel yapacağımızı söyledik. ps komutu ile, o anda çalışmakta olan process‘leri listeleyebileceğimizi gördük. ps -aux | grep bash komutu ile bash ile ilgili process’leri gördük. Tehlikeli olabileceğini düşündüğümüz komutlar hakkında man ve info komutlarını kullanarak bilgi alabileceğimizi gördük. apropos komutu ile benzer komutları listelettik. Binary File’ın derlenmiş ve çalıştırılabilir dosya demek olduğunu söyledik. file komutu ile dosya türünü görebileceğimizi gördük. Ctrl+A ve Ctrl+E ile yazmakta olduğumuz satırın başına veya sonuna atlayabileceğimizi gördük. /proc klasörüne göz attık. tecmint.com’un iyi bir kaynak olduğunu söyledik. Gnome’un bir window manager olduğunu söyledik. “Hard Link” ve “Soft Link” kavramlarını bir sınıf arkadaşımızdan öğreneceğimizin haberini aldık :) SID ve GID nedir? Araştırma ödevi verildi. “&amp;gt;”(redirection) ve “»“(concatenation) komutlarını inceledik. touch komutuyla oynadık. Umarım önemli bir şey atlamamışımdır. Sevgiler, Erhan</summary></entry><entry><title type="html">ASP.NET Core’da Anti Forgery Token Kullanımı</title><link href="/asp.net-core/2019/04/08/asp.net-core-anti-forgery-token.html" rel="alternate" type="text/html" title="ASP.NET Core'da Anti Forgery Token Kullanımı" /><published>2019-04-08T00:00:00+03:00</published><updated>2019-04-08T00:00:00+03:00</updated><id>/asp.net-core/2019/04/08/asp.net-core-anti-forgery-token</id><content type="html" xml:base="/asp.net-core/2019/04/08/asp.net-core-anti-forgery-token.html">&lt;p&gt;Anti-forgery token, çoğu zaman otomatik olarak sayfaya yerleşir ve kullanılır, fakat bazen sizin eklemeniz gerekebilir. Bu örnekteki sayfamız, herhangi bir controller action’a ulaşmayacak şekilde planlanmış bir sayfa. Fakat sonradan eklenen bir istek gereği bir controller action’a POST yapması gerekti. Bunun için bu sayfada bir anti-forgery token yaratmamız ve bu token’i yapacağımız POST request’te kullanmamız gerekiyor.&lt;/p&gt;

&lt;h3 id=&quot;anti-forgery-token-yaratma&quot;&gt;Anti-Forgery Token Yaratma&lt;/h3&gt;
&lt;p&gt;Anti-forgery token bulundurmasını istediğimiz cshtml dosyasının üst kısmına aşağıdaki satırları ekliyoruz:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf
@functions{
    public string GetAntiXsrfRequestToken()
    {
        return Xsrf.GetAndStoreTokens(Context).RequestToken;
    }
}

&amp;lt;input type=&quot;hidden&quot; id=&quot;RequestVerificationToken&quot;
       name=&quot;RequestVerificationToken&quot; value=&quot;@GetAntiXsrfRequestToken()&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bu satırlar, sayfamızda “RequestVerificationToken” id’sine sahip gizli bir input field yaratacak. Sayfadan yapacağımız POST request’in header’larına bu token’i eklememiz gerekecek.&lt;/p&gt;

&lt;h3 id=&quot;anti-forgery-token-kullanma&quot;&gt;Anti-Forgery Token Kullanma&lt;/h3&gt;
&lt;p&gt;Aşağıda JavaScript ile POST request’imizi yaptığımız function’ı görebilirsiniz. Template controller, Delete action’ına bir POST request yapıyoruz. URL kısmında bir id gönderiyoruz. POST başarılı olursa sayfayı yeniliyoruz, POST başarısız olursa “Delete failed.” uyarısı gösteriyoruz. İkinci “setRequestHeader” metod çağrısında anti-forgery token’i POST request’e nasıl dahil ettiğimizi görebilirsiniz.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function deleteTemplate(uidOftheItemToBeDeleted) {
    let postUrlFragment = 'id=' + uidOftheItemToBeDeleted;
    let xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function () {
        if (xhttp.readyState === XMLHttpRequest.DONE) {
            if (xhttp.status === 200) {
                location.reload();
            } else {
                alert('Delete failed.');
            }
        }
    };
    xhttp.open('POST', '..\/Template\/Delete', true);
    xhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    xhttp.setRequestHeader('RequestVerificationToken', document.getElementById('RequestVerificationToken').value);
    xhttp.send(postUrlFragment);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sevgiler.&lt;/p&gt;</content><author><name></name></author><summary type="html">Anti-forgery token, çoğu zaman otomatik olarak sayfaya yerleşir ve kullanılır, fakat bazen sizin eklemeniz gerekebilir. Bu örnekteki sayfamız, herhangi bir controller action’a ulaşmayacak şekilde planlanmış bir sayfa. Fakat sonradan eklenen bir istek gereği bir controller action’a POST yapması gerekti. Bunun için bu sayfada bir anti-forgery token yaratmamız ve bu token’i yapacağımız POST request’te kullanmamız gerekiyor.</summary></entry><entry><title type="html">İki Metini Hızlıca Karşılaştırma</title><link href="/productivity/2018/11/06/clipboard-compare.html" rel="alternate" type="text/html" title="İki Metini Hızlıca Karşılaştırma" /><published>2018-11-06T00:00:00+03:00</published><updated>2018-11-06T00:00:00+03:00</updated><id>/productivity/2018/11/06/clipboard-compare</id><content type="html" xml:base="/productivity/2018/11/06/clipboard-compare.html">&lt;p&gt;Clipboard Compare, iki metini hızlıca karşılaştırmak için güzel bir araç.&lt;/p&gt;

&lt;p&gt;Önce Beyond Compare’i yüklüyoruz, yükleme seçeneklerinde Clipboard Compare’in seçili olduğundan emin oluyoruz.&lt;/p&gt;

&lt;p&gt;Yükleme tamamlandıktan sonra System Tray’e eklenen Clipboard Compare ikonundan Options’a girip şu ayarları yapıyoruz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-11-06/clipboard-compare-options.png&quot; alt=&quot;Clipboard Compare options&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sonra karşılaştırmak istediğimiz metinleri sırayla kopyalıyoruz(Ctrl+C).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-11-06/texts-side-by-side.png&quot; alt=&quot;Texts to compare, side by side&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ve Ctrl+Alt+C yaptığımızda karşımıza karşılaştırma sonuçları geliyor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2018-11-06/compare-results.png&quot; alt=&quot;enter image description here&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Bunu çok sevdim çünkü tutorial takip ederken kodu copy-paste yapmamak lazım, kaynaktan bakarak yazmak lazım. Bu sayede hem kodun üzerinde daha çok düşünmüş oluyoruz, hem de bu yazım aşamasında rastlanabilecek sorunlara rastlayıp çözüyoruz, yazama işini pratikleştiriyoruz. Doğru yazıp yazmadığımızın teyidini de bu sayede çok hızlı yapabiliyoruz.&lt;/p&gt;</content><author><name></name></author><summary type="html">Clipboard Compare, iki metini hızlıca karşılaştırmak için güzel bir araç.</summary></entry><entry><title type="html">Blogun İlk Yazısı</title><link href="/casual/2018/10/29/blogun-ilk-yazisi.html" rel="alternate" type="text/html" title="Blogun İlk Yazısı" /><published>2018-10-29T00:00:00+03:00</published><updated>2018-10-29T00:00:00+03:00</updated><id>/casual/2018/10/29/blogun-ilk-yazisi</id><content type="html" xml:base="/casual/2018/10/29/blogun-ilk-yazisi.html">&lt;p&gt;İlk blog postumuza hoş geldiniz.&lt;/p&gt;

&lt;p&gt;Aslında ilk blogum değil. Öğrenciyken livejournal’da günlük tarzı yazılar yazıyordum. Boş şeyler yazıyordum ama benim için iyi oluyordu. Kendimi ifade etme yeteneğim gelişiyordu. O ara müzikle de uğraşıyorduk, şarkı sözü yazmaya çalışırken de faydasını görüyordum.&lt;/p&gt;

&lt;p&gt;Bir başka bloga da 2014’te başlamıştım. Bizim alankus.com’da bir wordpress instance’ında bir development günlüğü, türkçe tutorial’lar, ufak tüyolar vs. yazıyordum. Baya bi yazı birikmişti orada. Ama alankus.com’u yenilememeye karar verince ve o dönem blogu yedekleyecek kadar umursamayınca o da uçtu gitti.&lt;/p&gt;

&lt;p&gt;Bir süredir tekrar blog yazmaya başlamayı düşünüyordum ama bunu wordpress ile yapmak istemiyordum. Ücretsiz olarak wordpress.com’da yapsan bir sürü çirkin reklam, para verip temiz yapsan her sene domain parası, hosting parası…&lt;/p&gt;

&lt;p&gt;Bu Jekyll işini farkedince çok hoşuma gitti. Ruby geliştirme ortamında çalışan bir static site generator. Post’ları .md dosyası olarak oluşturuyorum, Jekyll statik bir siteye derliyor, github’a gönderiyorum. Github’da static hosting bedava, domain de gayet güzel: &lt;a href=&quot;https://erhanalankus.github.io&quot;&gt;erhanalankus.github.io&lt;/a&gt;. Hem de https kurulumunu öğrenme işini bir tık daha ileriye erteleme imkanı sundu :)&lt;/p&gt;

&lt;p&gt;Vatana millete hayırlı olsun!&lt;/p&gt;</content><author><name></name></author><summary type="html">İlk blog postumuza hoş geldiniz.</summary></entry><entry><title type="html">Orange Pi Deneme</title><link href="/test/2018/10/29/orange-pi-deneme.html" rel="alternate" type="text/html" title="Orange Pi Deneme" /><published>2018-10-29T00:00:00+03:00</published><updated>2018-10-29T00:00:00+03:00</updated><id>/test/2018/10/29/orange-pi-deneme</id><content type="html" xml:base="/test/2018/10/29/orange-pi-deneme.html">&lt;p&gt;Seedbox çalıştırdığım evdeki Orange Pi Zero üzerinde bir blog post oluşturmayı deniyorum. “Zamanında VIM ile blog yazardım” da diyebilcem bu sayede :)&lt;/p&gt;

&lt;p&gt;Sevgiler.&lt;/p&gt;</content><author><name></name></author><summary type="html">Seedbox çalıştırdığım evdeki Orange Pi Zero üzerinde bir blog post oluşturmayı deniyorum. “Zamanında VIM ile blog yazardım” da diyebilcem bu sayede :)</summary></entry><entry><title type="html">Plaka Şehir App Linkleri</title><link href="/promotion/2018/10/29/plaka-sehir-app-linkleri.html" rel="alternate" type="text/html" title="Plaka Şehir App Linkleri" /><published>2018-10-29T00:00:00+03:00</published><updated>2018-10-29T00:00:00+03:00</updated><id>/promotion/2018/10/29/plaka-sehir-app-linkleri</id><content type="html" xml:base="/promotion/2018/10/29/plaka-sehir-app-linkleri.html">&lt;p&gt;&lt;img src=&quot;/assets/images/plaka-sehir-banner.jpg&quot; alt=&quot;Plaka Sehir app banner&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Marketlerde üçüncü yılını dolduran Plaka Şehir uygulamamı aşağıdaki linklerden indirebilirsiniz:&lt;/p&gt;

&lt;h3 id=&quot;ios-app-storeda-plaka-Şehir&quot;&gt;iOS: &lt;a href=&quot;https://itunes.apple.com/tr/app/plaka-sehir/id1050212618&quot;&gt;App Store’da Plaka Şehir&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;android-play-storeda-plaka-Şehir&quot;&gt;Android: &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.erh.PlakaSehir&quot;&gt;Play Store’da Plaka Şehir&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html"></summary></entry></feed>